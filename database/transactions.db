CREATE TABLE IF NOT EXISTS transactions (
    id SERIAL PRIMARY KEY,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    order_id INTEGER REFERENCES orders(id) ON DELETE SET NULL,
    transaction_type VARCHAR(50) NOT NULL CHECK (transaction_type IN ('purchase', 'refund', 'deposit', 'withdrawal', 'adjustment')),
    amount DECIMAL(10,2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'USD',
    payment_method VARCHAR(50),
    status VARCHAR(20) DEFAULT 'completed' CHECK (status IN ('pending', 'completed', 'failed', 'cancelled')),
    description TEXT,
    reference_id VARCHAR(255),
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for better performance
CREATE INDEX IF NOT EXISTS idx_transactions_user_id ON transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_transactions_order_id ON transactions(order_id);
CREATE INDEX IF NOT EXISTS idx_transactions_type ON transactions(transaction_type);
CREATE INDEX IF NOT EXISTS idx_transactions_status ON transactions(status);
CREATE INDEX IF NOT EXISTS idx_transactions_created_at ON transactions(created_at);
CREATE INDEX IF NOT EXISTS idx_transactions_reference_id ON transactions(reference_id);

-- Enable RLS (Row Level Security)
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;

-- Policy: Only admins can view all transactions
CREATE POLICY "Admins can view all transactions" ON transactions
  FOR SELECT USING (
    exists (
      select 1 from users
      where users.id = auth.uid() and users.role = 'admin'
    )
  );

-- Policy: Service role can view all transactions (for backend operations)
CREATE POLICY "Service role can view all transactions" ON transactions
  FOR SELECT USING (auth.role() = 'service_role');

-- Policy: Only admins can create transactions
CREATE POLICY "Admins can create transactions" ON transactions
  FOR INSERT WITH CHECK (
    exists (
      select 1 from users
      where users.id = auth.uid() and users.role = 'admin'
    )
  );

-- Policy: Service role can create transactions (for backend automation)
CREATE POLICY "Service role can create transactions" ON transactions
  FOR INSERT WITH CHECK (auth.role() = 'service_role');

-- Policy: Only admins can update transactions
CREATE POLICY "Admins can update transactions" ON transactions
  FOR UPDATE USING (
    exists (
      select 1 from users
      where users.id = auth.uid() and users.role = 'admin'
    )
  );

-- Policy: Service role can update transactions (for backend operations)
CREATE POLICY "Service role can update transactions" ON transactions
  FOR UPDATE USING (auth.role() = 'service_role');

-- Policy: Only admins can delete transactions
CREATE POLICY "Admins can delete transactions" ON transactions
  FOR DELETE USING (
    exists (
      select 1 from users
      where users.id = auth.uid() and users.role = 'admin'
    )
  );

-- Policy: Service role can delete transactions (for backend operations)
CREATE POLICY "Service role can delete transactions" ON transactions
  FOR DELETE USING (auth.role() = 'service_role');

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_transactions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Trigger to update updated_at timestamp
CREATE TRIGGER update_transactions_updated_at 
    BEFORE UPDATE ON transactions 
    FOR EACH ROW 
    EXECUTE FUNCTION update_transactions_updated_at();

-- Function to generate transaction reference
CREATE OR REPLACE FUNCTION generate_transaction_reference(transaction_type VARCHAR)
RETURNS VARCHAR(255) AS $$
DECLARE
    ref_prefix VARCHAR(10);
    ref_num VARCHAR(255);
    counter INTEGER;
BEGIN
    -- Set prefix based on transaction type
    CASE transaction_type
        WHEN 'purchase' THEN ref_prefix := 'TXN-PUR';
        WHEN 'refund' THEN ref_prefix := 'TXN-REF';
        WHEN 'deposit' THEN ref_prefix := 'TXN-DEP';
        WHEN 'withdrawal' THEN ref_prefix := 'TXN-WTH';
        WHEN 'adjustment' THEN ref_prefix := 'TXN-ADJ';
        ELSE ref_prefix := 'TXN';
    END CASE;
    
    -- Get current timestamp as base
    ref_num := ref_prefix || '-' || to_char(now(), 'YYYYMMDD-HH24MISS');
    
    -- Check if this reference already exists
    SELECT COUNT(*) INTO counter FROM transactions WHERE reference_id LIKE ref_num || '%';
    
    -- If exists, append counter
    IF counter > 0 THEN
        ref_num := ref_num || '-' || (counter + 1);
    END IF;
    
    RETURN ref_num;
END;
$$ LANGUAGE plpgsql;

-- Function to delete associated order when transaction is deleted
CREATE OR REPLACE FUNCTION delete_associated_order()
RETURNS TRIGGER AS $$
BEGIN
    -- If there's an associated order, delete it
    IF OLD.order_id IS NOT NULL THEN
        DELETE FROM orders WHERE id = OLD.order_id;
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically delete associated order when transaction is deleted
CREATE TRIGGER delete_order_on_transaction_delete
    BEFORE DELETE ON transactions
    FOR EACH ROW
    EXECUTE FUNCTION delete_associated_order(); 